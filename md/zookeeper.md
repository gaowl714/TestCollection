### 特点

zk集群：一个leader，多个follower组成。

集群中只要有**半数以上**的节点存活就能正常工作，所以适合安装奇数服务器。

读操作：全局数据一致，每个server保存一份相同的数据副本，无论client连接到哪一个都一样。

写操作：更新请求顺序执行，来自同一个Client的更新请求按其发送顺序依次执行，数据更新原子性。

实时性，在一定时间内，client能读到最新数据。

### 数据结构

树形结构，每个节点默认存储**1MB**的数据，每个节点的路径就是唯一标识

### 应用场景

**统一命名服务**：分布式环境对服务器统一命名，便于识别。

​	例如访问网站时访问域名，类似nginx。

**统一配置管理**：分布式环境，同步配置文件。对配置文件能快速同步到各个节点上。

**统一集群管理**：分布式环境，实时掌握各个节点的状态。

**服务器动态上下线**：

**软负载均衡**：根据每个节点的访问数分配对应server。nginx

### conf

**tickTIme**：通讯心跳时间，用于客户端与服务端 或 服务端与服务端（默认2000毫秒）。

**initLimit**：Leader和Follower初始化通信时间（默认10个，10*2000ms）。

**syncLimit**：Leader和Follower同步通信时间（默认5个，5*2000ms）。

**dataDir**：保存zk的数据（默认为/tmp目录，Linux会定期删除，需要自定义目录）>

**clientPort**：客户端连接端口，通常不做修改（默认2181）。



**server.A=B:C:D：**A是个数字，表示这个是第几号服务器。B是这个服务器的地址。C是这个服务器的Follower与Leader交换信息的端口。D是万一集群中的Leader服务器挂了，需要一个端口来重新进行选举Leader。

#### 选举机制

#### 第一次启动

服务器1启动，发起一次选举，投自己一票，此时服务器票数1，不够半数以上，选举无法完成，服务器1状态为**LOOKING**。

服务器2启动，再发起一次选举，服务器1、2分别投自己一票并交换选票信息，**此时服务器1发现服务器2的myid比自己投票myid大，更改选票为服务器2**，然后2票大于集群数3的半数，服务器2为Leader，其他的为Follower。

服务器3启动，发起一次选举，此时1、2都不是**LOOKING**状态，不会更改选票信息，然后投自己一票，少数服从多数，服务器3为Follower。

#### 非第一次启动（无法与Leader保持连接）

**SID**：服务器ID，就是myid。

**ZXID**：事务ID，用来标识一次服务器状态的变更。

**Epoch**：每个Leader任期的代号，每投完一次票这个数据就会增加。

当集群中的一台机器进入Leader选举流程时，当前集群会出现两种情况，存在Leader或者不存在，存在则告知Leader信息进行连接，不存在则开始Leader选举。

**选举规则**：Epoch>ZXID>SID